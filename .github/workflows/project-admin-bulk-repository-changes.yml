name: Bulk Repository Changes

permissions:
  contents: write       # For CODEOWNERS file operations
  pull-requests: write  # For creating pull requests

on:
  workflow_dispatch:
    inputs:
      operation:
        description: 'Operation to perform'
        required: true
        type: choice
        options:
          - 'disable-wiki'
          - 'add-changelog-codeowners'
        default: 'disable-wiki'
      
      dry_run:
        description: 'Run in dry-run mode (no actual changes)'
        required: true
        type: boolean
        default: true
      
      # Repository Category Selection
      include_sandbox_repos:
        description: 'Include Sandbox API Repositories'
        required: false
        type: boolean
        default: true
      
      include_incubating_repos:
        description: 'Include Incubating API Repositories'
        required: false
        type: boolean
        default: true
      
      include_working_group_repos:
        description: 'Include Working Group Repositories'
        required: false
        type: boolean
        default: true
      
      include_other_repos:
        description: 'Include Other Repositories'
        required: false
        type: boolean
        default: true
      
      repository_filter:
        description: 'Repository name pattern (leave empty for all repos)'
        required: false
        type: string
        default: ''
      
      exclude_repos:
        description: 'Comma-separated list of repos to exclude'
        required: false
        type: string
        default: 'Governance,.github'
      
      commit_strategy:
        description: 'How to apply CODEOWNERS changes'
        required: false
        type: choice
        options:
          - 'pull-request'
          - 'direct-with-warning'
        default: 'pull-request'

jobs:
  get-repositories:
    runs-on: ubuntu-latest
    outputs:
      repositories: ${{ steps.get-repos.outputs.repositories }}
      total_count: ${{ steps.get-repos.outputs.total_count }}
    steps:
      - name: Get organization repositories
        id: get-repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';  // Hardcoded for CAMARA project
            const filterPattern = '${{ github.event.inputs.repository_filter }}';
            const excludeRepos = '${{ github.event.inputs.exclude_repos }}'.split(',').map(r => r.trim()).filter(r => r);
            
            // Category selection inputs
            const includeSandbox = ${{ fromJson(github.event.inputs.include_sandbox_repos) }};
            const includeIncubating = ${{ fromJson(github.event.inputs.include_incubating_repos) }};
            const includeWorkingGroup = ${{ fromJson(github.event.inputs.include_working_group_repos) }};
            const includeOther = ${{ fromJson(github.event.inputs.include_other_repos) }};
            
            console.log(`Getting repositories for organization: ${org}`);
            console.log(`Filter pattern: ${filterPattern}`);
            console.log(`Exclude repos: ${excludeRepos}`);
            console.log(`Include categories:`);
            console.log(`  - Sandbox API Repositories: ${includeSandbox}`);
            console.log(`  - Incubating API Repositories: ${includeIncubating}`);
            console.log(`  - Working Group Repositories: ${includeWorkingGroup}`);
            console.log(`  - Other Repositories: ${includeOther}`);
            
            let allRepos = [];
            let page = 1;
            
            while (true) {
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              allRepos = allRepos.concat(response.data);
              page++;
            }
            
            // Function to categorize repository based on topics
            function categorizeRepository(topics) {
              if (topics.includes('sandbox-api-repository')) {
                return 'sandbox';
              } else if (topics.includes('incubating-api-repository')) {
                return 'incubating';
              } else if (topics.includes('workinggroup')) {
                return 'working-group';
              } else {
                return 'other';
              }
            }
            
            // Filter repositories based on criteria and categories
            let filteredRepos = [];
            let categoryCounts = { sandbox: 0, incubating: 0, 'working-group': 0, other: 0 };
            
            for (const repo of allRepos) {
              // Skip archived repositories
              if (repo.archived) continue;
              
              // Skip excluded repositories  
              if (excludeRepos.includes(repo.name)) continue;
              
              // Apply name filter pattern if provided
              if (filterPattern && !repo.name.includes(filterPattern)) continue;
              
              // Categorize repository based on topics
              const category = categorizeRepository(repo.topics || []);
              categoryCounts[category]++;
              
              // Check if this category is selected for inclusion
              let includeThisRepo = false;
              switch (category) {
                case 'sandbox':
                  includeThisRepo = includeSandbox;
                  break;
                case 'incubating':
                  includeThisRepo = includeIncubating;
                  break;
                case 'working-group':
                  includeThisRepo = includeWorkingGroup;
                  break;
                case 'other':
                  includeThisRepo = includeOther;
                  break;
              }
              
              if (includeThisRepo) {
                filteredRepos.push(repo);
              }
            }
            
            const repositories = filteredRepos.map(repo => ({
              name: repo.name,
              full_name: repo.full_name,
              default_branch: repo.default_branch,
              category: categorizeRepository(repo.topics || [])
            }));
            
            console.log(`\nRepository counts by category:`);
            console.log(`  - Sandbox API Repositories: ${categoryCounts.sandbox}`);
            console.log(`  - Incubating API Repositories: ${categoryCounts.incubating}`);
            console.log(`  - Working Group Repositories: ${categoryCounts['working-group']}`);
            console.log(`  - Other Repositories: ${categoryCounts.other}`);
            console.log(`\nSelected ${repositories.length} repositories for processing`);
            
            core.setOutput('repositories', JSON.stringify(repositories));
            core.setOutput('total_count', repositories.length);

  execute-changes:
    needs: get-repositories
    if: fromJson(needs.get-repositories.outputs.total_count) > 0
    strategy:
      matrix:
        repository: ${{ fromJson(needs.get-repositories.outputs.repositories) }}
      max-parallel: 5
      fail-fast: false
    uses: ./.github/workflows/project-admin-repository-worker.yml
    with:
      repository_name: ${{ matrix.repository.name }}
      repository_full_name: ${{ matrix.repository.full_name }}
      default_branch: ${{ matrix.repository.default_branch }}
      operation: ${{ github.event.inputs.operation }}
      dry_run: ${{ fromJson(github.event.inputs.dry_run) }}
      commit_strategy: ${{ github.event.inputs.commit_strategy }}
    secrets:
      CAMARA_TOKEN: ${{ secrets.CAMARA_TOKEN }}

  collect-results:
    needs: [get-repositories, execute-changes]
    if: always() && fromJson(needs.get-repositories.outputs.total_count) > 0
    runs-on: ubuntu-latest
    steps:
  collect-results:
    needs: [get-repositories, execute-changes]
    if: always() && fromJson(needs.get-repositories.outputs.total_count) > 0
    runs-on: ubuntu-latest
    steps:
      - name: Download all result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          path: artifacts/
          merge-multiple: true

      - name: Collect and summarize results
        uses: actions/github-script@v7
        with:
          script: |
            const repositories = JSON.parse('${{ needs.get-repositories.outputs.repositories }}');
            const operation = '${{ github.event.inputs.operation }}';
            const dryRun = ${{ fromJson(github.event.inputs.dry_run) }};
            const commitStrategy = '${{ github.event.inputs.commit_strategy }}' || 'N/A';
            
            console.log('Collecting results from artifacts...');
            
            const fs = require('fs');
            const path = require('path');
            
            // Read all result files
            let results = [];
            let statusCounts = {};
            
            try {
              const artifactsDir = 'artifacts';
              if (fs.existsSync(artifactsDir)) {
                const files = fs.readdirSync(artifactsDir);
                console.log(`Found ${files.length} result files`);
                
                for (const file of files) {
                  if (file.endsWith('.json')) {
                    try {
                      const filePath = path.join(artifactsDir, file);
                      const resultData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                      
                      // Get operation status and details
                      const operationStatus = resultData.status || 'unknown';
                      let details = '';
                      
                      // Create detailed status description
                      switch (operationStatus) {
                        case 'no-change':
                          details = operation === 'disable-wiki' ? 'Wiki already disabled' : 'CHANGELOG.MD rule already exists';
                          break;
                        case 'direct-commit':
                          details = `Direct commit successful${resultData.commit_sha ? ` (${resultData.commit_sha.substring(0, 7)})` : ''}`;
                          break;
                        case 'direct-commit-blocked':
                          details = 'Direct commit blocked by branch protection';
                          break;
                        case 'pr-created':
                          details = `Pull request created${resultData.pr_number ? ` (#${resultData.pr_number})` : ''}`;
                          break;
                        case 'wiki-disabled':
                          details = 'Wiki disabled successfully';
                          break;
                        case 'wiki-has-content':
                          details = 'Wiki has content - skipped for safety';
                          break;
                        case 'would-disable-wiki':
                          details = 'Dry run: Would disable wiki';
                          break;
                        case 'would-create-pr':
                          details = 'Dry run: Would create pull request';
                          break;
                        case 'would-commit-or-warn':
                          details = 'Dry run: Would attempt direct commit';
                          break;
                        case 'no-codeowners-file':
                          details = 'No CODEOWNERS file found';
                          break;
                        default:
                          details = operationStatus;
                      }
                      
                      // Count statuses
                      if (statusCounts[operationStatus]) {
                        statusCounts[operationStatus]++;
                      } else {
                        statusCounts[operationStatus] = 1;
                      }
                      
                      // Find repository category
                      const repoInfo = repositories.find(r => r.name === resultData.repository);
                      const category = repoInfo ? repoInfo.category : 'unknown';
                      
                      results.push({
                        repository: resultData.repository,
                        category: category,
                        operation_status: operationStatus,
                        details: details,
                        pr_url: resultData.pr_url || '',
                        pr_number: resultData.pr_number || '',
                        commit_sha: resultData.commit_sha || ''
                      });
                      
                    } catch (parseError) {
                      console.log(`Error parsing ${file}: ${parseError.message}`);
                    }
                  }
                }
              } else {
                console.log('No artifacts directory found');
              }
            } catch (error) {
              console.log(`Error reading artifacts: ${error.message}`);
            }
            
            // If no results from artifacts, fall back to job analysis
            if (results.length === 0) {
              console.log('No artifact results found, falling back to job analysis...');
              
              // Get all jobs from this workflow run
              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });
              
              // Find execute-changes jobs (matrix jobs)
              const matrixJobs = jobs.data.jobs.filter(job => 
                job.name.includes('execute-changes') && 
                job.name.includes('(')
              );
              
              for (const repo of repositories) {
                const matrixJob = matrixJobs.find(job => 
                  job.name.includes(`(${repo.name})`) || job.name.includes(repo.name)
                );
                
                let operationStatus = 'unknown';
                let details = '';
                
                if (matrixJob) {
                  const jobConclusion = matrixJob.conclusion || 'in_progress';
                  
                  if (jobConclusion === 'success') {
                    operationStatus = dryRun ? 'dry-run-success' : 'success';
                    details = dryRun ? 'Dry run completed successfully' : 'Operation completed successfully';
                  } else {
                    operationStatus = jobConclusion;
                    details = 'Check job logs for details';
                  }
                }
                
                if (statusCounts[operationStatus]) {
                  statusCounts[operationStatus]++;
                } else {
                  statusCounts[operationStatus] = 1;
                }
                
                results.push({
                  repository: repo.name,
                  category: repo.category || 'other',
                  operation_status: operationStatus,
                  details: details,
                  pr_url: '',
                  pr_number: '',
                  commit_sha: ''
                });
              }
            }
            
            console.log(`Collected ${results.length} results`);
            
            // Generate execution summary
            const timestamp = new Date().toISOString();
            const totalRepos = repositories.length;
            
            // Create markdown report
            const reportLines = [
              '# CAMARA Bulk Repository Changes - Execution Report',
              '',
              `**Execution Time:** ${timestamp}`,
              `**Operation:** ${operation}`,
              `**Commit Strategy:** ${commitStrategy}`,
              `**Mode:** ${dryRun ? 'DRY RUN' : 'LIVE EXECUTION'}`,
              `**Total Repositories:** ${totalRepos}`,
              '',
              '## Operation Status Summary',
              '',
              '| Operation Status | Count | Percentage |',
              '|------------------|-------|------------|'
            ];
            
            for (const [status, count] of Object.entries(statusCounts)) {
              const percentage = totalRepos > 0 ? ((count / totalRepos) * 100).toFixed(1) : '0.0';
              const emoji = status.includes('success') || status === 'direct-commit' || status === 'pr-created' || status === 'wiki-disabled' ? '‚úÖ' : 
                           status.includes('fail') || status.includes('error') ? '‚ùå' : 
                           status.includes('blocked') || status.includes('content') || status.includes('no-') ? '‚ö†Ô∏è' :
                           status.includes('would-') ? 'üß™' : 'üìä';
              reportLines.push(`| ${emoji} ${status} | ${count} | ${percentage}% |`);
            }
            
            reportLines.push('');
            reportLines.push('## Repository Results');
            reportLines.push('');
            reportLines.push('| Repository | Category | Operation Status | Details |');
            reportLines.push('|------------|----------|------------------|---------|');
            
            // Sort results: failures/warnings first, then success, then by repository name  
            results.sort((a, b) => {
              const aIsIssue = a.operation_status.includes('fail') || a.operation_status.includes('blocked') || a.operation_status.includes('no-') || a.operation_status.includes('error');
              const bIsIssue = b.operation_status.includes('fail') || b.operation_status.includes('blocked') || b.operation_status.includes('no-') || b.operation_status.includes('error');
              
              if (aIsIssue && !bIsIssue) return -1;
              if (!aIsIssue && bIsIssue) return 1;
              return a.repository.localeCompare(b.repository);
            });
            
            for (const result of results) {
              const emoji = result.operation_status.includes('success') || result.operation_status === 'direct-commit' || result.operation_status === 'pr-created' || result.operation_status === 'wiki-disabled' ? '‚úÖ' : 
                           result.operation_status.includes('fail') || result.operation_status.includes('error') ? '‚ùå' : 
                           result.operation_status.includes('blocked') || result.operation_status.includes('content') || result.operation_status.includes('no-') ? '‚ö†Ô∏è' :
                           result.operation_status.includes('would-') ? 'üß™' : 'üìä';
              
              let detailsWithLinks = result.details;
              if (result.pr_number && result.pr_url) {
                detailsWithLinks += ` [PR #${result.pr_number}](${result.pr_url})`;
              }
              
              reportLines.push(`| ${result.repository} | ${result.category} | ${emoji} ${result.operation_status} | ${detailsWithLinks} |`);
            }
            
            reportLines.push('');
            reportLines.push('## Next Steps');
            reportLines.push('');
            
            if (dryRun) {
              reportLines.push('### After Dry Run Review:');
              reportLines.push('- Review the operation statuses above to understand what will happen');
              reportLines.push('- Address any issues (missing CODEOWNERS files, blocked operations)');
              reportLines.push('- Run the same operation with dry_run disabled for live execution');
            } else {
              reportLines.push('### After Live Execution:');
              reportLines.push('- ‚úÖ **Successful operations**: Changes have been applied');
              reportLines.push('- ‚ö†Ô∏è **Blocked/Warning operations**: May need manual intervention or different strategy');
              reportLines.push('- ‚ùå **Failed operations**: Review job logs and resolve issues manually');
              reportLines.push('- üîÑ **Re-run capability**: Target specific repositories or change strategy as needed');
            }
            
            reportLines.push('');
            reportLines.push('---');
            reportLines.push('*Generated by CAMARA project-admin bulk workflow*');
            
            const markdownReport = reportLines.join('\n');
            
            // Create CSV data
            let csvLines = ['Repository,Category,Operation Status,Details,PR Number,PR URL,Commit SHA'];
            for (const result of results) {
              csvLines.push(`"${result.repository}","${result.category}","${result.operation_status}","${result.details}","${result.pr_number}","${result.pr_url}","${result.commit_sha}"`);
            }
            const csvData = csvLines.join('\n');
            
            // Write files using Node.js fs
            const fs = require('fs');
            
            // Create results directory
            if (!fs.existsSync('results')) {
              fs.mkdirSync('results');
            }
            
            // Write markdown report
            fs.writeFileSync('results/bulk-changes-report.md', markdownReport);
            console.log('‚úÖ Created markdown report');
            
            // Write CSV data
            fs.writeFileSync('results/bulk-changes-results.csv', csvData);
            console.log('‚úÖ Created CSV results');
            
            // Write JSON data for programmatic access
            const jsonReport = {
              metadata: {
                timestamp: timestamp,
                operation: operation,
                commit_strategy: commitStrategy,
                dry_run: dryRun,
                total_repositories: totalRepos
              },
              summary: statusCounts,
              results: results
            };
            
            fs.writeFileSync('results/bulk-changes-data.json', JSON.stringify(jsonReport, null, 2));
            console.log('‚úÖ Created JSON data');
            
            // Add summary to job summary
            core.summary.addRaw(markdownReport);
            await core.summary.write();
            
            console.log(`üìä Results summary completed - processed ${totalRepos} repositories`);

      - name: Upload results artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bulk-changes-results-${{ github.run_number }}
          path: results/
          retention-days: 30

  summary:
    needs: [get-repositories, execute-changes, collect-results]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Final summary
        uses: actions/github-script@v7
        with:
          script: |
            const totalRepos = ${{ needs.get-repositories.outputs.total_count }};
            const operation = '${{ github.event.inputs.operation }}';
            const dryRun = ${{ fromJson(github.event.inputs.dry_run) }};
            const executionResult = '${{ needs.execute-changes.result }}';
            const collectionResult = '${{ needs.collect-results.result }}';
            
            let summary = `## Bulk Repository Changes Summary\n\n`;
            summary += `**Operation**: ${operation}\n`;
            summary += `**Mode**: ${dryRun ? 'DRY RUN' : 'LIVE'}\n`;
            summary += `**Total Repositories**: ${totalRepos}\n`;
            summary += `**Execution Status**: ${executionResult}\n`;
            summary += `**Results Collection**: ${collectionResult}\n\n`;
            
            if (totalRepos === 0) {
              summary += `‚ö†Ô∏è No repositories matched the selection criteria.\n\n`;
              summary += `**Check your filters:**\n`;
              summary += `- Repository categories selected\n`;
              summary += `- Repository name filters\n`;
              summary += `- Excluded repositories list\n`;
            } else {
              summary += `üìä **Detailed results available in:**\n`;
              summary += `- Job summary above (markdown report)\n`;
              summary += `- Downloadable artifacts (CSV, JSON, markdown files)\n\n`;
              
              if (dryRun) {
                summary += `üß™ **This was a dry run** - no actual changes were made.\n`;
                summary += `Review the detailed results and run with dry_run=false for live execution.\n`;
              } else {
                summary += `‚úÖ **Live execution completed**.\n`;
                summary += `Check the detailed results for individual repository outcomes.\n`;
              }
            }
            
            console.log(summary);
            core.summary.addRaw(summary);
            await core.summary.write();